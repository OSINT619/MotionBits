<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Particle Animation - MotionBits</title>
  <style>
    /* Reset & base */
    * {
      box-sizing: border-box;
    }
    body, html {
      margin: 0; padding: 0; height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f0f0f3;
      color: #333;
      display: flex;
      align-items: stretch;
      overflow: hidden;
      user-select: none;
    }

    /* Container split */
    .container {
      display: flex;
      width: 100%;
      height: 100vh;
      padding: 2rem;
      gap: 2rem;
      background: #f0f0f3;
    }

    /* Instruction panel */
    .instructions {
      flex: 0 0 350px;
      background: #f0f0f3;
      border-radius: 24px;
      padding: 2rem;
      box-shadow:
        8px 8px 16px #bebebe,
        -8px -8px 16px #ffffff;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    /* Embossed Heading */
    h1 {
      margin: 0 0 1rem 0;
      font-size: 2.8rem;
      font-weight: 900;
      color: #222;
      text-align: center;
      /* Deep embossed */
      text-shadow:
        2px 2px 0 #a8a8a8,
        4px 4px 6px #d6d6d6,
        -1px -1px 1px #fff,
        -4px -4px 8px #f8f8f8;
      user-select: text;
    }

    /* Instruction text with beveled effect */
    p {
      font-size: 1.05rem;
      line-height: 1.5;
      color: #444;
      margin-bottom: 1.5rem;
      /* Beveled text */
      text-shadow:
        1px 1px 0 #fff,
        2px 2px 4px #bbb;
      user-select: text;
    }

    /* Emphasized text */
    strong {
      color: #222;
      font-weight: 700;
      text-shadow:
        1px 1px 0 #fff,
        2px 2px 3px #aaa;
    }

    /* Canvas container */
    .animation-area {
      flex: 1;
      background: #f0f0f3;
      border-radius: 32px;
      box-shadow:
        12px 12px 24px #bebebe,
        -12px -12px 24px #ffffff;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
    }

    /* Canvas fills container */
    canvas#c {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 32px;
      box-shadow:
        inset 4px 4px 10px #c1c1c1,
        inset -4px -4px 10px #ffffff;
      background-color: black;
    }

    /* Responsive adjustments */
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
        padding: 1rem;
      }
      .instructions {
        flex: none;
        width: 100%;
        margin-bottom: 1.5rem;
        border-radius: 20px;
      }
      .animation-area {
        flex: none;
        height: 400px;
        border-radius: 20px;
      }
      h1 {
        font-size: 2rem;
      }
      p {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <aside class="instructions" aria-label="Instructions">
      <h1>Particle Animation</h1>
      <p>
        This is a <strong>WebGL2 particle animation</strong> using <em>custom shaders</em> running on an HTML5 canvas.
      </p>
      <p>
        <strong>How to use the code:</strong><br />
        1. Copy the entire HTML snippet including the <code>&lt;canvas&gt;</code>, <code>&lt;style&gt;</code>, and <code>&lt;script&gt;</code> blocks.<br />
        2. Paste it into a blank HTML file in your project.<br />
        3. Open that file in any modern browser (Chrome, Firefox, Edge, Safari).<br />
        4. The animation runs fullscreen on the canvas element.<br />
      </p>
      <p>
        <strong>Notes:</strong> This requires a WebGL2 compatible browser. The animation resizes automatically to the canvas size.
      </p>
    </aside>

    <section class="animation-area" aria-label="Particle animation preview">
      <canvas id="c"></canvas>
    </section>
  </div>

  <script>
  {
    const c = document.getElementById("c");
    const gl = c.getContext("webgl2");

    if (!gl) {
      alert("WebGL 2 not supported");
    }

    const vertexShaderSource = `#version 300 es
      in vec4 a_position;
      void main() {
        gl_Position = a_position;
      }
    `;

    const fragmentShaderSource = `#version 300 es
      precision highp float;
      out vec4 o;
      uniform vec2 r;
      uniform float t;

      void main() {
        vec3 p, v;
        vec4 colorPalette[5];
        colorPalette[0] = vec4(0.05, 0.15, 0.35, 0.0);
        colorPalette[1] = vec4(0.25, 0.5, 0.75, 0.0);
        colorPalette[2] = vec4(0.85, 0.65, 0.45, 0.0);
        colorPalette[3] = vec4(1.0, 0.9, 0.8, 0.0);
        colorPalette[4] = vec4(0.5, 0.3, 0.7, 0.0);

        float i = 0.0, z = 0.0, d = 0.0, l = 0.0;
        vec4 finalColor = vec4(0.0);

        for(i=0.0; i<90.0; i+=1.0) {
          p = z * (gl_FragCoord.rgb * 2.0 - r.xyy) / r.y;
          p.z += 2.0;

          vec2 grid = fract(p.xy * 5.0);
          vec2 center = vec2(0.5);
          float distToCenter = length(grid - center);
          float cellEffect = smoothstep(0.4, 0.5, distToCenter);

          p.xy += (cellEffect - 0.5) * 0.3;

          l = length(p);
          v = vec3(atan(p.x, p.z), atan(p.y, length(p.xz)), log(l)) * 8.0 + t;
          v.xy += sin(t+v.z) * vec2(0.6, 0.3);

          z += d = length(cos(v) + sin(v.yzx + v + t - l)) * l * 0.025;
          finalColor += (colorPalette[int(mod(i, 5.0))] / (d + 1e-6)) * (1.0 - pow(smoothstep(0.6, 1.4, length(gl_FragCoord.xy/r.xy)), 1.5));
        }

        o = pow(vec4(tanh(finalColor.rgb / 4000.0) + vec3(0.02, 0.01, 0.03), 1.0), vec4(2.2));
      }
    `;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader), source);
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

    function main() {
      if (!vertexShader || !fragmentShader) {
        console.error("shader creation failed");
        return;
      }

      const program = createProgram(vertexShader, fragmentShader);
      if (!program) {
        console.error("shader program creation failed");
        return;
      }

      const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
      const resolutionUniformLocation = gl.getUniformLocation(program, "r");
      const timeUniformLocation = gl.getUniformLocation(program, "t");

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

      function render(time) {
        time *= 0.001;
        c.width = c.clientWidth;
        c.height = c.clientHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform1f(timeUniformLocation, time);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    main();
  }
  </script>
</body>
</html>
